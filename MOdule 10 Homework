{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "c7339e32",
   "metadata": {
    "id": "VHENp8fir0Dh",
    "papermill": {
     "duration": 0.004563,
     "end_time": "2025-05-09T17:08:26.700003",
     "exception": false,
     "start_time": "2025-05-09T17:08:26.695440",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "---\n",
    "\n",
    "## Homework 10: Gradient Descent Models and Robust Evaluation (8% of Grade)\n",
    "\n",
    "**Important:** This homework is worth 8% of your final grade. Please make sure to complete all exercises thoroughly and to your best ability.\n",
    "\n",
    "**Academic Integrity: Avoid directly copying and pasting code from Large Language Models (LLMs). While LLMs can be helpful for understanding concepts and getting started, it's crucial to write your own code and demonstrate your understanding of the material.**\n",
    "\n",
    "**Exercise 1: Iowa Housing Dataset - Gradient Boosting and XGBoost**\n",
    "\n",
    "**1.1 Gradient Boosting:**\n",
    "\n",
    "a. Using the `iowa_data_subset` and the `preprocessor_iowa`, create a pipeline that includes a `GradientBoostingRegressor` model.\n",
    "\n",
    "b. Use `GridSearchCV` or `RandomizedSearchCV` with 5-fold cross-validation to find the best hyperparameters for the `GradientBoostingRegressor`, including `n_estimators`, `learning_rate`, and `max_depth`.\n",
    "\n",
    "c. Evaluate the model's performance using the negative mean absolute error (MAE) as the scoring metric. Print the best hyperparameters and the corresponding MAE score.\n",
    "\n",
    "**1.2 XGBoost:**\n",
    "\n",
    "a. Similar to the previous step, create a pipeline with an `XGBRegressor` model.\n",
    "\n",
    "b. Use `GridSearchCV` or `RandomizedSearchCV` with 5-fold cross-validation to find the best hyperparameters for the `XGBRegressor`, including `n_estimators`, `learning_rate`, and `max_depth`.\n",
    "\n",
    "c. Evaluate the model's performance using the negative MAE as the scoring metric. Print the best hyperparameters and the corresponding MAE score.\n",
    "\n",
    "**1.3 Comparison:**\n",
    "\n",
    "a. Compare the performance of the `GradientBoostingRegressor` and the `XGBRegressor` based on their MAE scores. Which model performed better on the Iowa Housing dataset?\n",
    "\n",
    "b. Briefly discuss the advantages and disadvantages of each model.\n",
    "\n",
    "**Exercise 2: Adult Dataset - Gradient Boosting and XGBoost**\n",
    "\n",
    "**2.1 Gradient Boosting:**\n",
    "\n",
    "a. Using the `adult_data`, the `X_adult`, and `y_adult`, and the `preprocessor_adult`, create a pipeline that includes a `GradientBoostingClassifier` model.\n",
    "\n",
    "b. Use `GridSearchCV` or `RandomizedSearchCV` with 5-fold cross-validation to find the best hyperparameters for the `GradientBoostingClassifier`, including `n_estimators`, `learning_rate`, and `max_depth`.\n",
    "\n",
    "c. Evaluate the model's performance using accuracy as the scoring metric. Print the best hyperparameters and the corresponding accuracy score.\n",
    "\n",
    "**2.2 XGBoost:**\n",
    "\n",
    "a. Similar to the previous step, create a pipeline with an `XGBClassifier` model.\n",
    "\n",
    "b. Use `GridSearchCV` or `RandomizedSearchCV` with 5-fold cross-validation to find the best hyperparameters for the `XGBClassifier`, including `n_estimators`, `learning_rate`, and `max_depth`.\n",
    "\n",
    "c. Evaluate the model's performance using accuracy as the scoring metric. Print the best hyperparameters and the corresponding accuracy score.\n",
    "\n",
    "**2.3 Comparison:**\n",
    "\n",
    "a. Compare the performance of the `GradientBoostingClassifier` and the `XGBClassifier` based on their accuracy scores. Which model performed better on the Adult dataset?\n",
    "\n",
    "b. Briefly discuss the advantages and disadvantages of each model in the context of classification.\n",
    "\n",
    "**Submission:**\n",
    "\n",
    "Submit your Colab notebook with the completed exercises. Make sure your code is well-organized and includes comments explaining your steps. Also, provide a brief discussion of your findings and comparisons."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b94c56f3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-09T17:08:26.710285Z",
     "iopub.status.busy": "2025-05-09T17:08:26.709805Z",
     "iopub.status.idle": "2025-05-09T17:08:32.428144Z",
     "shell.execute_reply": "2025-05-09T17:08:32.427017Z"
    },
    "papermill": {
     "duration": 5.725136,
     "end_time": "2025-05-09T17:08:32.429868",
     "exception": false,
     "start_time": "2025-05-09T17:08:26.704732",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Logging into Kaggle Hub...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "01c4ffb13af34b7e8d7c29d642b75aeb",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "VBox(children=(HTML(value='<center> <img\\nsrc=https://www.kaggle.com/static/images/site-logo.png\\nalt=\\'Kaggle…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Kaggle Hub login successful.\n"
     ]
    }
   ],
   "source": [
    "# 1. Library Import Code Cell\n",
    "# Import Libraries\n",
    "\n",
    "# Import necessary libraries for data manipulation and machine learning tasks.\n",
    "import numpy as np # Import numpy for numerical operations, especially array manipulations.\n",
    "import pandas as pd # Import pandas for data manipulation and analysis using DataFrames.\n",
    "\n",
    "from xgboost import XGBRegressor, XGBClassifier # Import XGBoost models for regression and classification.\n",
    "\n",
    "from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier,GradientBoostingRegressor # Import ensemble models for regression.\n",
    "from sklearn.linear_model import LogisticRegression # Import Logistic Regression for classification.\n",
    "\n",
    "from sklearn.model_selection import cross_val_score, train_test_split, GridSearchCV, RandomizedSearchCV, KFold # Import model selection tools.\n",
    "\n",
    "from sklearn.metrics import mean_absolute_error, accuracy_score, f1_score, roc_auc_score # Import metrics for model evaluation.\n",
    "\n",
    "from sklearn.impute import SimpleImputer # Import SimpleImputer for handling missing values.\n",
    "from sklearn.preprocessing import OneHotEncoder, StandardScaler # Import preprocessing tools.\n",
    "from sklearn.compose import ColumnTransformer # Import ColumnTransformer for applying different transformations to columns.\n",
    "from sklearn.pipeline import Pipeline # Import Pipeline to create composite estimators.\n",
    "\n",
    "# IMPORTANT: Login to Kaggle Hub to access datasets.\n",
    "print(\"\\nLogging into Kaggle Hub...\")\n",
    "import kagglehub # Import kagglehub library.\n",
    "kagglehub.login() # Authenticate with Kaggle.\n",
    "print(\"Kaggle Hub login successful.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "e9325dea",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-09T17:08:32.439885Z",
     "iopub.status.busy": "2025-05-09T17:08:32.439303Z",
     "iopub.status.idle": "2025-05-09T17:08:32.666620Z",
     "shell.execute_reply": "2025-05-09T17:08:32.665563Z"
    },
    "papermill": {
     "duration": 0.234877,
     "end_time": "2025-05-09T17:08:32.668816",
     "exception": false,
     "start_time": "2025-05-09T17:08:32.433939",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "----- Data Loading and Preparation -----\n",
      "\n",
      "Downloading Iowa Housing dataset from Kaggle...\n",
      "Iowa Housing dataset downloaded successfully to: /kaggle/input/home-data-for-ml-course\n",
      "\n",
      "Loading Iowa Housing training data...\n",
      "Iowa dataset loaded.\n",
      "\n",
      "Defining features and target for Iowa dataset...\n",
      "Features (X) and target (y) for Iowa dataset prepared.\n",
      "\n",
      "Identifying numerical and categorical columns for Iowa dataset...\n",
      "Categorical and numerical columns identified for Iowa dataset.\n",
      "\n",
      "Defining preprocessing steps for numerical and categorical features (Iowa dataset)...\n",
      "Preprocessing steps defined for Iowa dataset.\n",
      "\n",
      "Creating a baseline pipeline with preprocessor and RandomForestRegressor...\n",
      "Baseline pipeline (preprocessor + RandomForestRegressor) created.\n",
      "\n",
      "----- Data Loading and Preparation Completed for Iowa Dataset -----\n"
     ]
    }
   ],
   "source": [
    "# --- Load Iowa Housing Data ---\n",
    "\n",
    "print(\"\\n----- Data Loading and Preparation -----\")\n",
    "\n",
    "# Download Iowa Housing dataset from Kaggle.\n",
    "print(\"\\nDownloading Iowa Housing dataset from Kaggle...\")\n",
    "dansbecker_home_data_for_ml_course_path = kagglehub.dataset_download('dansbecker/home-data-for-ml-course')\n",
    "# kagglehub.dataset_download: Download dataset from Kaggle.\n",
    "# 'dansbecker/home-data-for-ml-course': Dataset identifier.\n",
    "print('Iowa Housing dataset downloaded successfully to:', dansbecker_home_data_for_ml_course_path)\n",
    "\n",
    "# Load Iowa training data.\n",
    "print(\"\\nLoading Iowa Housing training data...\")\n",
    "iowa_file_path = dansbecker_home_data_for_ml_course_path + '/train.csv' # Path to training data.\n",
    "iowa_data = pd.read_csv(iowa_file_path) # Load data into pandas DataFrame.\n",
    "print(\"Iowa dataset loaded.\")\n",
    "\n",
    "# Define features and target for Iowa dataset (consistent with previous modules).\n",
    "print(\"\\nDefining features and target for Iowa dataset...\")\n",
    "features_to_use_iowa = ['LotArea', 'OverallQual', 'YearBuilt', 'TotalBsmtSF', 'GrLivArea',\n",
    "                        'GarageArea', 'SalePrice', 'Neighborhood', 'BldgType', 'HouseStyle',\n",
    "                        'ExterQual', 'KitchenQual', 'FireplaceQu']\n",
    "                        # Feature list.\n",
    "\n",
    "iowa_data_subset = iowa_data[features_to_use_iowa].copy() # Create subset with selected features.\n",
    "\n",
    "y = iowa_data_subset['SalePrice']\n",
    "# Target variable (SalePrice).\n",
    "\n",
    "X = iowa_data_subset.drop('SalePrice', axis=1)\n",
    "# Features (all columns except SalePrice).\n",
    "print(\"Features (X) and target (y) for Iowa dataset prepared.\")\n",
    "\n",
    "# Identify numerical and categorical columns for Iowa dataset.\n",
    "print(\"\\nIdentifying numerical and categorical columns for Iowa dataset...\")\n",
    "\n",
    "numerical_cols_iowa = X.select_dtypes(exclude='object').columns\n",
    "# Numerical columns (non-object type).\n",
    "\n",
    "categorical_cols_iowa = X.select_dtypes(include='object').columns\n",
    "# Categorical columns (object type).\n",
    "\n",
    "print(\"Categorical and numerical columns identified for Iowa dataset.\")\n",
    "\n",
    "# Define Preprocessing for numerical and categorical features (same as before).\n",
    "print(\"\\nDefining preprocessing steps for numerical and categorical features (Iowa dataset)...\")\n",
    "\n",
    "# 1. Define preprocessing steps for numerical and categorical features\n",
    "# Create a pipeline for numerical features\n",
    "numerical_transformer_iowa = Pipeline(steps=[\n",
    "                                     ('imputer', SimpleImputer(strategy='median')),\n",
    "                                     # Impute missing values with the median\n",
    "\n",
    "                                     ('scaler', StandardScaler())\n",
    "                                     # Scale numerical features using StandardScaler\n",
    "])\n",
    "\n",
    "# Create a pipeline for categorical features\n",
    "categorical_transformer_iowa = Pipeline(steps=[\n",
    "                                       ('imputer', SimpleImputer(strategy='most_frequent')),\n",
    "                                       # Impute missing values with the most frequent value\n",
    "\n",
    "                                       ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=False))\n",
    "                                       # One-hot encode categorical features\n",
    "])\n",
    "\n",
    "# Create ColumnTransformer for preprocessing.\n",
    "preprocessor_iowa = ColumnTransformer(\n",
    "                        transformers=[\n",
    "                                     ('num', numerical_transformer_iowa, numerical_cols_iowa),\n",
    "                                     # Numerical preprocessing.\n",
    "                                     ('cat', categorical_transformer_iowa, categorical_cols_iowa)])\n",
    "                                     # Categorical preprocessing.\n",
    "print(\"Preprocessing steps defined for Iowa dataset.\")\n",
    "\n",
    "# Create a baseline pipeline using RandomForestRegressor (often used as a comparison point)\n",
    "# This pipeline is used in Exercise 2.1 as the starting point to modify.\n",
    "print(\"\\nCreating a baseline pipeline with preprocessor and RandomForestRegressor...\")\n",
    "\n",
    "pipeline_model = Pipeline(steps=[\n",
    "                                ('preprocessor', preprocessor_iowa),\n",
    "                                ('model', RandomForestRegressor(n_estimators=100, random_state=0))])\n",
    "print(\"Baseline pipeline (preprocessor + RandomForestRegressor) created.\")\n",
    "\n",
    "print(\"\\n----- Data Loading and Preparation Completed for Iowa Dataset -----\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5da877f2",
   "metadata": {
    "papermill": {
     "duration": 0.003925,
     "end_time": "2025-05-09T17:08:32.677240",
     "exception": false,
     "start_time": "2025-05-09T17:08:32.673315",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Exercise 1: Iowa Housing Dataset - Gradient Boosting and XGBoost"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "41a01031",
   "metadata": {
    "papermill": {
     "duration": 0.005475,
     "end_time": "2025-05-09T17:08:32.686795",
     "exception": false,
     "start_time": "2025-05-09T17:08:32.681320",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## 1 · Gradient Boosting Regressor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "822aab4f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-09T17:08:32.697194Z",
     "iopub.status.busy": "2025-05-09T17:08:32.695950Z",
     "iopub.status.idle": "2025-05-09T17:14:37.727685Z",
     "shell.execute_reply": "2025-05-09T17:14:37.726241Z"
    },
    "papermill": {
     "duration": 365.041856,
     "end_time": "2025-05-09T17:14:37.732592",
     "exception": false,
     "start_time": "2025-05-09T17:08:32.690736",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fitting 5 folds for each of 50 candidates, totalling 250 fits\n",
      "\n",
      "[GradientBoostingRegressor]\n",
      "Best CV MAE : 17605.868216849954\n",
      "Best params : {'model__learning_rate': 0.0578327334701464, 'model__max_depth': 3, 'model__n_estimators': 486, 'model__subsample': 0.7439325288187336}\n"
     ]
    }
   ],
   "source": [
    "from scipy.stats import randint, uniform, loguniform, reciprocal\n",
    "\n",
    "# ----- pipeline -----\n",
    "gbr_pipe = Pipeline([\n",
    "    ('prep',   preprocessor_iowa),\n",
    "    ('model',  GradientBoostingRegressor(random_state=0))\n",
    "])\n",
    "\n",
    "# ----- Hyperparameters for XGBRegressor ----\n",
    "# Huge range of parameters\n",
    "gbr_param_dist = {\n",
    "    \"model__n_estimators\": randint(200, 2000),\n",
    "    \"model__learning_rate\": uniform(0.01, 0.29),\n",
    "    \"model__max_depth\": randint(2, 6),\n",
    "    \"model__subsample\":  uniform(0.7, 0.3)\n",
    "}\n",
    "\n",
    "## RandomizedSearchCV model deployment\n",
    "gbr_search = RandomizedSearchCV(\n",
    "    estimator       = gbr_pipe,\n",
    "    param_distributions = gbr_param_dist,\n",
    "    n_iter          = 50,\n",
    "    cv              = 5,\n",
    "    scoring         = \"neg_mean_absolute_error\",\n",
    "    n_jobs          = -1,\n",
    "    random_state    = 0,\n",
    "    verbose         = 1\n",
    ")\n",
    "\n",
    "gbr_search.fit(X, y)\n",
    "\n",
    "print(\"\\n[GradientBoostingRegressor]\")\n",
    "print(\"Best CV MAE :\", -gbr_search.best_score_)\n",
    "print(\"Best params :\", gbr_search.best_params_)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "40d9422c",
   "metadata": {
    "papermill": {
     "duration": 0.003719,
     "end_time": "2025-05-09T17:14:37.740436",
     "exception": false,
     "start_time": "2025-05-09T17:14:37.736717",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## 2 · XGBoost Regressor - with L1/L2, min_child_weight & early-stopping"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "f5a7eb95",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-09T17:14:37.750643Z",
     "iopub.status.busy": "2025-05-09T17:14:37.750180Z",
     "iopub.status.idle": "2025-05-09T17:15:31.605364Z",
     "shell.execute_reply": "2025-05-09T17:15:31.604022Z"
    },
    "papermill": {
     "duration": 53.866688,
     "end_time": "2025-05-09T17:15:31.611197",
     "exception": false,
     "start_time": "2025-05-09T17:14:37.744509",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fitting 5 folds for each of 80 candidates, totalling 400 fits\n",
      "\n",
      "[XGBRegressor – regularised + early stopping]\n",
      "Best CV MAE : 18307.6271345168\n",
      "Best params : {'model__colsample_bytree': 0.6388592806405162, 'model__learning_rate': 0.012713444408394458, 'model__max_depth': 4, 'model__min_child_weight': 4, 'model__n_estimators': 1504, 'model__reg_alpha': 0.38162429990899654, 'model__reg_lambda': 0.027991776684745243, 'model__subsample': 0.754957408602135}\n"
     ]
    }
   ],
   "source": [
    "# ------------------------------------------------------------------\n",
    "# ①  Build a fixed category list from the whole dataset\n",
    "# ------------------------------------------------------------------\n",
    "full_categories = [sorted(X[col].dropna().unique())\n",
    "                   for col in categorical_cols_iowa]\n",
    "\n",
    "categorical_transformer_iowa = Pipeline([\n",
    "    (\"imputer\", SimpleImputer(strategy=\"most_frequent\")),\n",
    "    (\"onehot\",  OneHotEncoder(\n",
    "                    handle_unknown=\"ignore\",\n",
    "                    sparse_output=False,\n",
    "                    categories=full_categories      # ← freeze schema\n",
    "                ))\n",
    "])\n",
    "\n",
    "preprocessor_iowa = ColumnTransformer([\n",
    "    (\"num\", numerical_transformer_iowa, numerical_cols_iowa),\n",
    "    (\"cat\", categorical_transformer_iowa, categorical_cols_iowa)\n",
    "])\n",
    "\n",
    "# ------------------------------------------------------------------\n",
    "# ②  Validation split and *manual* transform for early stopping\n",
    "# ------------------------------------------------------------------\n",
    "X_train, X_valid, y_train, y_valid = train_test_split(\n",
    "    X, y, test_size=0.20, random_state=0)\n",
    "\n",
    "preprocessor_iowa.fit(X_train) # fit once on training rows\n",
    "X_valid_enc = preprocessor_iowa.transform(X_valid)\n",
    "\n",
    "# ------------------------------------------------------------------\n",
    "# ③  XGBRegressor pipeline with early_stopping_rounds in ctor\n",
    "# ------------------------------------------------------------------\n",
    "from xgboost import XGBRegressor\n",
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.model_selection import RandomizedSearchCV\n",
    "\n",
    "xgbr_pipe = Pipeline([\n",
    "    (\"prep\",  preprocessor_iowa),\n",
    "    (\"model\", XGBRegressor(\n",
    "                 objective    =\"reg:squarederror\",\n",
    "                 eval_metric  =\"mae\",\n",
    "                 n_jobs       =-1,\n",
    "                 random_state =0,\n",
    "                 early_stopping_rounds=50 # ← moved here\n",
    "             ))\n",
    "])\n",
    "\n",
    "param_dist = {\n",
    "    \"model__n_estimators\":      randint(400, 4000),\n",
    "    \"model__learning_rate\":    uniform(0.01, 0.29),\n",
    "    \"model__max_depth\":        randint(2, 8),\n",
    "    \"model__subsample\":        uniform(0.7, 0.3),\n",
    "    \"model__colsample_bytree\": uniform(0.5, 0.5),\n",
    "    \"model__min_child_weight\": randint(1, 10),\n",
    "    \"model__reg_alpha\":        reciprocal(1e-4, 1e1), # L1\n",
    "    \"model__reg_lambda\":       reciprocal(1e-3, 1e2) # L2\n",
    "}\n",
    "\n",
    "xgbr_search = RandomizedSearchCV(\n",
    "    xgbr_pipe, param_dist, n_iter=80, cv=5,\n",
    "    scoring=\"neg_mean_absolute_error\", n_jobs=-1,\n",
    "    random_state=0, verbose=1\n",
    ")\n",
    "\n",
    "# Same fit_params as before—now they’ll match dimensions\n",
    "fit_params = {\n",
    "    \"model__eval_set\": [(X_valid_enc, y_valid)],\n",
    "    \"model__verbose\":  0\n",
    "}\n",
    "\n",
    "xgbr_search.fit(X_train, y_train, **fit_params)\n",
    "\n",
    "print(\"\\n[XGBRegressor – regularised + early stopping]\")\n",
    "print(\"Best CV MAE :\", -xgbr_search.best_score_)\n",
    "print(\"Best params :\", xgbr_search.best_params_)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4340ba72",
   "metadata": {
    "papermill": {
     "duration": 0.003866,
     "end_time": "2025-05-09T17:15:31.619486",
     "exception": false,
     "start_time": "2025-05-09T17:15:31.615620",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Takeaways:\n",
    "* ## When we look at the results of Regression models, Gradient Boosting Regressor wins again XGBRegressor but only by $702 of MAE on average. It looks like regularization techniques like min_child_weight, alpha and lambda, subsampling approach and other parameters didn't make much of a difference in this dataset.\n",
    "\n",
    "* ## However, both of them are still neck and neck so both miss the true sale price by about $17 600–18 300."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5d2e1e3c",
   "metadata": {
    "papermill": {
     "duration": 0.003812,
     "end_time": "2025-05-09T17:15:31.627250",
     "exception": false,
     "start_time": "2025-05-09T17:15:31.623438",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Exercise 2: Adult Dataset - Gradient Boosting and XGBoost"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "e3f5bb4d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-09T17:15:31.636595Z",
     "iopub.status.busy": "2025-05-09T17:15:31.636248Z",
     "iopub.status.idle": "2025-05-09T17:16:03.977214Z",
     "shell.execute_reply": "2025-05-09T17:16:03.975664Z"
    },
    "papermill": {
     "duration": 32.347916,
     "end_time": "2025-05-09T17:16:03.979072",
     "exception": false,
     "start_time": "2025-05-09T17:15:31.631156",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\n",
      "----- Adult Dataset Loading and Preparation (Commented Out - Activate if needed) -----\n",
      "--2025-05-09 17:15:31--  https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\r\n",
      "Resolving archive.ics.uci.edu (archive.ics.uci.edu)... failed: Temporary failure in name resolution.\r\n",
      "wget: unable to resolve host address ‘archive.ics.uci.edu’\r\n",
      "\n",
      "Identifying numerical and categorical columns for Iowa dataset...\n",
      "Categorical and numerical columns identified for Iowa dataset.\n",
      "\n",
      "Defining preprocessing steps for numerical and categorical features (Iowa dataset)...\n"
     ]
    }
   ],
   "source": [
    "# --- Adult Dataset Loading (if needed later, can be activated) ---\n",
    "print(\"\\n\\n----- Adult Dataset Loading and Preparation (Commented Out - Activate if needed) -----\")\n",
    "# Adult dataset loading code (commented out for now, activate if you plan to use Adult dataset in later modules)\n",
    "!wget https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\n",
    "\n",
    "# Load the Adult dataset using pandas (you may need to download it first)\n",
    "adult_data = pd.read_csv('/kaggle/input/adult-census-income/adult.csv')\n",
    "\n",
    "#Adding column names.\n",
    "column_names_adult = [\"age\", \"workclass\", \"fnlwgt\", \"education\", \"education-num\", \"marital-status\",\n",
    "                      \"occupation\", \"relationship\", \"race\", \"sex\", \"capital-gain\", \"capital-loss\",\n",
    "                      \"hours-per-week\", \"native-country\", \"income\"]\n",
    "\n",
    "X_adult = adult_data.drop('income', axis=1)\n",
    "# Features (all columns except 'income').\n",
    "y_adult = adult_data['income']\n",
    "# Target variable'income'\n",
    "y_adult = adult_data[\"income\"].map({\">50K\":1, \"<=50K\":0})\n",
    "\n",
    "# Identify numerical and categorical columns for Iowa dataset.\n",
    "print(\"\\nIdentifying numerical and categorical columns for Iowa dataset...\")\n",
    "\n",
    "numerical_cols_adult = X_adult.select_dtypes(exclude='object').columns\n",
    "# Numerical columns (non-object type).\n",
    "\n",
    "categorical_cols_adult = X_adult.select_dtypes(include='object').columns\n",
    "# Categorical columns (object type).\n",
    "\n",
    "print(\"Categorical and numerical columns identified for Iowa dataset.\")\n",
    "\n",
    "# Define Preprocessing for numerical and categorical features (same as before).\n",
    "print(\"\\nDefining preprocessing steps for numerical and categorical features (Iowa dataset)...\")\n",
    "\n",
    "# 1. Define preprocessing steps for numerical and categorical features (similar to Iowa)\n",
    "# Create a pipeline for numerical features\n",
    "numerical_transformer_adult = Pipeline(steps=[\n",
    "                                      ('imputer', SimpleImputer(strategy='median')),\n",
    "                                      # Impute missing values with the median\n",
    "\n",
    "                                      ('scaler', StandardScaler())\n",
    "                                      # Scale numerical features using StandardScaler\n",
    "])\n",
    "\n",
    "# Create a pipeline for categorical features\n",
    "categorical_transformer_adult = Pipeline(steps=[\n",
    "                                        ('imputer', SimpleImputer(strategy='most_frequent')),\n",
    "                                        # Impute missing values with the most frequent value\n",
    "\n",
    "                                        ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=False))\n",
    "                                        # One-hot encode categorical features\n",
    "])\n",
    "\n",
    "# Create ColumnTransformer for preprocessing.\n",
    "preprocessor_adult = ColumnTransformer(\n",
    "                        transformers=[\n",
    "                                     ('num', numerical_transformer_adult, numerical_cols_adult),\n",
    "                                     # Numerical preprocessing.\n",
    "                                     ('cat', categorical_transformer_adult, categorical_cols_adult)])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b1744cb8",
   "metadata": {
    "papermill": {
     "duration": 0.003947,
     "end_time": "2025-05-09T17:16:03.987384",
     "exception": false,
     "start_time": "2025-05-09T17:16:03.983437",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## 2.1 GradientBoostingClassifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "a78ba95c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-09T17:16:03.998191Z",
     "iopub.status.busy": "2025-05-09T17:16:03.997271Z",
     "iopub.status.idle": "2025-05-09T17:31:13.054491Z",
     "shell.execute_reply": "2025-05-09T17:31:13.053149Z"
    },
    "papermill": {
     "duration": 909.070703,
     "end_time": "2025-05-09T17:31:13.062233",
     "exception": false,
     "start_time": "2025-05-09T17:16:03.991530",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fitting 5 folds for each of 10 candidates, totalling 50 fits\n",
      "\n",
      "[GradientBoostingClassifier]\n",
      "Best CV accuracy : 0.8125988714312067\n",
      "Best params      : {'model__learning_rate': 0.08642641877141598, 'model__max_depth': 4, 'model__n_estimators': 288, 'model__subsample': 0.8178354388302489}\n"
     ]
    }
   ],
   "source": [
    "from sklearn.ensemble import GradientBoostingClassifier\n",
    "\n",
    "# ----- pipeline -----\n",
    "gbc_pipe = Pipeline([\n",
    "    (\"prep\",  preprocessor_adult),\n",
    "    (\"model\", GradientBoostingClassifier(random_state=0))\n",
    "])\n",
    "\n",
    "# ----- Hyperparameters for GradientBoosting -----\n",
    "gbc_param_dist = {\n",
    "    \"model__n_estimators\":  randint(200, 500),\n",
    "    \"model__learning_rate\": uniform(0.01, 0.16),\n",
    "    \"model__max_depth\":     randint(2, 5), \n",
    "    \"model__subsample\":     uniform(0.7, 0.3)\n",
    "}\n",
    "\n",
    "## RandomizedSearchCV model deployment\n",
    "gbc_search = RandomizedSearchCV(\n",
    "    estimator       = gbc_pipe,\n",
    "    param_distributions = gbc_param_dist,\n",
    "    n_iter          = 10,\n",
    "    cv              = 5,\n",
    "    scoring         = \"accuracy\",\n",
    "    n_jobs          = -1,\n",
    "    random_state    = 0,\n",
    "    verbose         = 1\n",
    ")\n",
    "\n",
    "gbc_search.fit(X_adult, y_adult)\n",
    "\n",
    "print(\"\\n[GradientBoostingClassifier]\")\n",
    "print(\"Best CV accuracy :\", gbc_search.best_score_)\n",
    "print(\"Best params      :\", gbc_search.best_params_)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "79dd1133",
   "metadata": {
    "papermill": {
     "duration": 0.004567,
     "end_time": "2025-05-09T17:31:13.071724",
     "exception": false,
     "start_time": "2025-05-09T17:31:13.067157",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## 2.2 XGBClassifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "5af5ccb9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-09T17:31:13.082720Z",
     "iopub.status.busy": "2025-05-09T17:31:13.082370Z",
     "iopub.status.idle": "2025-05-09T17:54:03.563769Z",
     "shell.execute_reply": "2025-05-09T17:54:03.563086Z"
    },
    "papermill": {
     "duration": 1370.491846,
     "end_time": "2025-05-09T17:54:03.568299",
     "exception": false,
     "start_time": "2025-05-09T17:31:13.076453",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fitting 5 folds for each of 60 candidates, totalling 300 fits\n",
      "\n",
      "[XGBClassifier – regularised]\n",
      "Best CV accuracy : 0.8730418303769978\n",
      "Best params      : {'model__colsample_bytree': 0.8942727561532593, 'model__learning_rate': 0.02080113452231566, 'model__max_depth': 5, 'model__min_child_weight': 1, 'model__n_estimators': 747, 'model__reg_alpha': 0.001982041856987242, 'model__reg_lambda': 0.07397171532829963, 'model__subsample': 0.8762798905589166}\n"
     ]
    }
   ],
   "source": [
    "from xgboost import XGBClassifier\n",
    "\n",
    "# ------------------------------------------------------------\n",
    "# 1 · Train / validation split for early stopping\n",
    "# ------------------------------------------------------------\n",
    "X_tr, X_val, y_tr, y_val = train_test_split(\n",
    "    X_adult, y_adult, test_size=0.20, random_state=0, stratify=y_adult)\n",
    "\n",
    "\n",
    "preprocessor_adult.fit(X_tr) # fit once on training rows\n",
    "X_valid_enc = preprocessor_adult.transform(X_val)\n",
    "\n",
    "# ------------------------------------------------------------\n",
    "# 2 · Pipeline with XGBClassifier\n",
    "# ------------------------------------------------------------\n",
    "xgbc_pipe = Pipeline([\n",
    "    (\"prep\",  preprocessor_adult),\n",
    "    (\"model\", XGBClassifier(\n",
    "                 objective    =\"binary:logistic\",\n",
    "                 eval_metric  =\"logloss\",    # watched for early stopping\n",
    "                 n_jobs       =-1,\n",
    "                 random_state =0\n",
    "             ))\n",
    "])\n",
    "\n",
    "# ------------------------------------------------------------\n",
    "# 3 · Hyper-parameter search space (includes L1, L2, min_child_weight)\n",
    "# ------------------------------------------------------------\n",
    "xgbc_param_dist = {\n",
    "    \"model__n_estimators\":      randint(400, 1000),\n",
    "    \"model__learning_rate\":    uniform(0.01, 0.19),\n",
    "    \"model__max_depth\":        randint(2, 8),\n",
    "    \"model__subsample\":        uniform(0.7, 0.3),\n",
    "    \"model__colsample_bytree\": uniform(0.5, 0.5),\n",
    "    \"model__min_child_weight\": randint(1, 10),\n",
    "    \"model__reg_alpha\":        loguniform(1e-4, 1e1),   # L1\n",
    "    \"model__reg_lambda\":       loguniform(1e-3, 1e2)    # L2\n",
    "}\n",
    "\n",
    "xgbc_search = RandomizedSearchCV(\n",
    "    estimator           = xgbc_pipe,\n",
    "    param_distributions = xgbc_param_dist,\n",
    "    n_iter              = 60,\n",
    "    cv                  = 5,\n",
    "    scoring             = \"accuracy\",         # choose another metric if preferred\n",
    "    n_jobs              = -1,\n",
    "    random_state        = 0,\n",
    "    verbose             = 1\n",
    ")\n",
    "\n",
    "# ------------------------------------------------------------\n",
    "# 4 · Early-stopping parameters (passed straight through the pipeline)\n",
    "# ------------------------------------------------------------\n",
    "fit_params = {\n",
    "    \"model__eval_set\"             : [(X_valid_enc, y_val)],\n",
    "    #\"model__early_stopping_rounds\": 50,\n",
    "    \"model__verbose\"              : 0\n",
    "}\n",
    "\n",
    "# ------------------------------------------------------------\n",
    "# 5 · Fit & report\n",
    "# ------------------------------------------------------------\n",
    "xgbc_search.fit(X_tr, y_tr, **fit_params)\n",
    "\n",
    "print(\"\\n[XGBClassifier – regularised]\")\n",
    "print(\"Best CV accuracy :\",  xgbc_search.best_score_)\n",
    "print(\"Best params      :\",  xgbc_search.best_params_)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b2311fd7",
   "metadata": {
    "papermill": {
     "duration": 0.00436,
     "end_time": "2025-05-09T17:54:03.577473",
     "exception": false,
     "start_time": "2025-05-09T17:54:03.573113",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Takeaways:\n",
    "* ## When we look at the results of Classification models, regularised XGBoost model makes roughly 6 extra correct predictions out of every 100 cases compared with Gradient Boosting. It shows that XGBoost should be chosen for this data but not to forget that adult data is so small dataset so the result doesn't mean to choose XGBoost instead of Gradient Descent in every datasets.\n",
    "* ## What make difference are adjusting regularization parameters like alpha, lambda and min_child_weight, giving low learning rate range options and applying restricted early stopping parameters."
   ]
  }
 ],
 "metadata": {
  "colab": {
   "authorship_tag": "ABX9TyMhtj26fWfLza/Hewmvj5Ig",
   "provenance": []
  },
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 225,
     "sourceId": 498,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 108980,
     "sourceId": 260251,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 31012,
   "isGpuEnabled": false,
   "isInternetEnabled": false,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 2744.95624,
   "end_time": "2025-05-09T17:54:06.205836",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-05-09T17:08:21.249596",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "01c4ffb13af34b7e8d7c29d642b75aeb": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "VBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "VBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "VBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_bf31888789c3488a8eed0dce0eab1d08",
        "IPY_MODEL_461432f6fbe54bc2bfde20151b438318",
        "IPY_MODEL_a4cdd365d5314d149511fba26c4f3ce4",
        "IPY_MODEL_61b8b00c5e204ebea81d9a3121341d91",
        "IPY_MODEL_068008edafea4822978a58129da173f7"
       ],
       "layout": "IPY_MODEL_bf4c00822c3341f7aac1068ab4b5954b",
       "tabbable": null,
       "tooltip": null
      }
     },
     "068008edafea4822978a58129da173f7": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_8aedd96c420e4a178871900f4e3ddd8f",
       "placeholder": "​",
       "style": "IPY_MODEL_27820b137636437b92a71b8d93b44eff",
       "tabbable": null,
       "tooltip": null,
       "value": "\n<b>Thank You</b></center>"
      }
     },
     "2499e468cdde40b6b9162e2611eb3d3d": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "27820b137636437b92a71b8d93b44eff": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "3e608254fddf45fb8c983554ecd5837c": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "461432f6fbe54bc2bfde20151b438318": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "TextModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "TextModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "TextView",
       "continuous_update": true,
       "description": "Username:",
       "description_allow_html": false,
       "disabled": false,
       "layout": "IPY_MODEL_cccfb60668804be8a20908b112ebaac1",
       "placeholder": "​",
       "style": "IPY_MODEL_ac7d13c30dfd4d03a9575b3eab7dc9b3",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "61b8b00c5e204ebea81d9a3121341d91": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ButtonModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ButtonModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ButtonView",
       "button_style": "",
       "description": "Login",
       "disabled": false,
       "icon": "",
       "layout": "IPY_MODEL_ad101db8c3e34ec3bac13c92d0cf88a8",
       "style": "IPY_MODEL_f30537816f9e46688fac9603c7c4ff6f",
       "tabbable": null,
       "tooltip": null
      }
     },
     "8aedd96c420e4a178871900f4e3ddd8f": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "a4cdd365d5314d149511fba26c4f3ce4": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "PasswordModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "PasswordModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "PasswordView",
       "continuous_update": true,
       "description": "Token:",
       "description_allow_html": false,
       "disabled": false,
       "layout": "IPY_MODEL_3e608254fddf45fb8c983554ecd5837c",
       "placeholder": "​",
       "style": "IPY_MODEL_d775c7871d47477fac35a66ba3e2a7c7",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "ac7d13c30dfd4d03a9575b3eab7dc9b3": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "TextStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "TextStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "ad101db8c3e34ec3bac13c92d0cf88a8": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "bdb44e63f27243d4b1ff3e97f494f95d": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "bf31888789c3488a8eed0dce0eab1d08": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_bdb44e63f27243d4b1ff3e97f494f95d",
       "placeholder": "​",
       "style": "IPY_MODEL_2499e468cdde40b6b9162e2611eb3d3d",
       "tabbable": null,
       "tooltip": null,
       "value": "<center> <img\nsrc=https://www.kaggle.com/static/images/site-logo.png\nalt='Kaggle'> <br> Create an API token from <a\nhref=\"https://www.kaggle.com/settings/account\" target=\"_blank\">your Kaggle\nsettings page</a> and paste it below along with your Kaggle username. <br> </center>"
      }
     },
     "bf4c00822c3341f7aac1068ab4b5954b": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": "center",
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": "flex",
       "flex": null,
       "flex_flow": "column",
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "50%"
      }
     },
     "cccfb60668804be8a20908b112ebaac1": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "d775c7871d47477fac35a66ba3e2a7c7": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "TextStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "TextStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "f30537816f9e46688fac9603c7c4ff6f": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ButtonStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ButtonStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "button_color": null,
       "font_family": null,
       "font_size": null,
       "font_style": null,
       "font_variant": null,
       "font_weight": null,
       "text_color": null,
       "text_decoration": null
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
