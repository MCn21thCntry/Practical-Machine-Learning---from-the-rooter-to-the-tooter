{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "fc409535",
   "metadata": {
    "id": "5JW2nZtOzYSB",
    "papermill": {
     "duration": 0.003324,
     "end_time": "2025-05-16T21:54:08.588234",
     "exception": false,
     "start_time": "2025-05-16T21:54:08.584910",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Module 11 Homework: Deep Dive into Gradient Descent Models and XGBoost - Hyperparameter Tuning\n",
    "\n",
    "###**This homework will be 8% of the course's total**\n",
    "\n",
    "This homework focuses on comparing the performance and efficiency of Grid Search and Randomized Search for hyperparameter tuning, using the Iowa Housing dataset and the Gradient Boosting Regressor.\n",
    "\n",
    "**1. Refine the parameter grid:**\n",
    "\n",
    "- Based on the results of your Randomized Search for the Gradient Boosting Regressor on the Iowa Housing dataset, create a narrower, more focused parameter grid. This grid should center around the best parameters found by the Randomized Search."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "8d67eda0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-16T21:54:08.595557Z",
     "iopub.status.busy": "2025-05-16T21:54:08.595111Z",
     "iopub.status.idle": "2025-05-16T21:54:13.696160Z",
     "shell.execute_reply": "2025-05-16T21:54:13.695052Z"
    },
    "papermill": {
     "duration": 5.106654,
     "end_time": "2025-05-16T21:54:13.697852",
     "exception": false,
     "start_time": "2025-05-16T21:54:08.591198",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Libraries and helper functions imported successfully.\n"
     ]
    }
   ],
   "source": [
    "# Setup and Library Imports\n",
    "# Let's begin by importing the necessary libraries and setting up helper functions.\n",
    "\n",
    "# Import core libraries for data manipulation and numerical operations\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import os # Import os for basic path handling\n",
    "import time # Import time to measure execution duration\n",
    "\n",
    "# Import machine learning tools from scikit-learn\n",
    "from sklearn.model_selection import train_test_split, GridSearchCV, RandomizedSearchCV\n",
    "\n",
    "# Import search objects\n",
    "from sklearn.pipeline import Pipeline\n",
    "# For building robust workflows\n",
    "from sklearn.preprocessing import OneHotEncoder, StandardScaler\n",
    "# Preprocessing steps: One-Hot Encoding, Scaling\n",
    "from sklearn.compose import ColumnTransformer\n",
    "# To apply different transformations to different columns\n",
    "from sklearn.impute import SimpleImputer\n",
    "# Imputer for missing values\n",
    "\n",
    "# Import the models we'll be working with\n",
    "from sklearn.ensemble import GradientBoostingRegressor, GradientBoostingClassifier\n",
    "# Scikit-learn's GBM\n",
    "from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier\n",
    "# Our baseline models\n",
    "import xgboost as xgb\n",
    "# The powerful XGBoost library\n",
    "\n",
    "# Import evaluation metrics\n",
    "from sklearn.metrics import mean_squared_error, r2_score\n",
    "# Regression metrics\n",
    "from sklearn.metrics import accuracy_score, f1_score, classification_report\n",
    "# Classification metrics\n",
    "\n",
    "# Import visualization libraries (optional, but helpful for analysis)\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "# Import scipy.stats for parameter distributions in RandomizedSearchCV\n",
    "from scipy.stats import uniform, randint\n",
    "\n",
    "# Set random seed for reproducibility for consistent results\n",
    "np.random.seed(42)\n",
    "\n",
    "# Helper function to calculate Root Mean Squared Error (RMSE) - useful for regression evaluation\n",
    "def rmse(y_true, y_pred):\n",
    "    \"\"\"Calculates the Root Mean Squared Error.\"\"\"\n",
    "    return np.sqrt(mean_squared_error(y_true, y_pred))\n",
    "\n",
    "print(\"Libraries and helper functions imported successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "fc5ffb89",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-16T21:54:13.705780Z",
     "iopub.status.busy": "2025-05-16T21:54:13.705297Z",
     "iopub.status.idle": "2025-05-16T21:54:14.136626Z",
     "shell.execute_reply": "2025-05-16T21:54:14.135594Z"
    },
    "papermill": {
     "duration": 0.43673,
     "end_time": "2025-05-16T21:54:14.138182",
     "exception": false,
     "start_time": "2025-05-16T21:54:13.701452",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "----- Raw Data Loading -----\n",
      "\n",
      "Logging into Kaggle Hub...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7267fb8622c34cc186f7ae96b7f615a0",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "VBox(children=(HTML(value='<center> <img\\nsrc=https://www.kaggle.com/static/images/site-logo.png\\nalt=\\'Kaggle…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Kaggle Hub login successful.\n",
      "\n",
      "Downloading Iowa Housing dataset from Kaggle...\n",
      "Iowa Housing dataset downloaded successfully to: /kaggle/input/home-data-for-ml-course\n",
      "\n",
      "Loading Iowa Housing training data...\n",
      "Iowa dataset loaded.\n",
      "Raw Iowa Housing data shape: (1460, 81)\n"
     ]
    }
   ],
   "source": [
    "# Data Loading (Raw Datasets)\n",
    "# We'll load the raw datasets.\n",
    "# This cell focuses only on getting the raw data into pandas DataFrames.\n",
    "\n",
    "print(\"\\n----- Raw Data Loading -----\")\n",
    "\n",
    "# IMPORTANT: Login to Kaggle Hub to access datasets like Iowa Housing.\n",
    "# You will be prompted to enter your Kaggle username and API key if you are not already authenticated.\n",
    "\n",
    "print(\"\\nLogging into Kaggle Hub...\")\n",
    "try:\n",
    "    import kagglehub # Import kagglehub library.\n",
    "    kagglehub.login() # Authenticate with Kaggle.\n",
    "    print(\"Kaggle Hub login successful.\")\n",
    "    kaggle_login_successful = True\n",
    "except Exception as e:\n",
    "    print(f\"Kaggle Hub login failed: {e}\")\n",
    "    print(\"You might need to install kagglehub (`pip install kagglehub`) or authenticate manually (`kaggle.json`).\")\n",
    "    print(\"Skipping Kaggle data download for Iowa Housing.\")\n",
    "    kaggle_login_successful = False\n",
    "    # Create dummy path/data if login fails to prevent errors in subsequent cells trying to access these variables\n",
    "    dansbecker_home_data_for_ml_course_path = None\n",
    "    iowa_data = None\n",
    "\n",
    "\n",
    "# --- Iowa Housing Dataset (Regression) ---\n",
    "# Iowa Housing Data (Regression):** Downloading and Loading `train.csv`.\n",
    "if kaggle_login_successful:\n",
    "    try:\n",
    "        print(\"\\nDownloading Iowa Housing dataset from Kaggle...\")\n",
    "        # 'dansbecker/home-data-data-for-ml-course' is the dataset identifier on Kaggle.\n",
    "        dansbecker_home_data_for_ml_course_path = kagglehub.dataset_download('dansbecker/home-data-for-ml-course')\n",
    "        print('Iowa Housing dataset downloaded successfully to:', dansbecker_home_data_for_ml_course_path)\n",
    "\n",
    "        # Load Iowa training data.\n",
    "        print(\"\\nLoading Iowa Housing training data...\")\n",
    "        # Construct the full file path for the training data CSV.\n",
    "        iowa_file_path = os.path.join(dansbecker_home_data_for_ml_course_path, 'train.csv')\n",
    "        iowa_data = pd.read_csv(iowa_file_path) # Load data into pandas DataFrame.\n",
    "        print(\"Iowa dataset loaded.\")\n",
    "        print(f\"Raw Iowa Housing data shape: {iowa_data.shape}\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error downloading or loading Iowa Housing dataset: {e}\")\n",
    "        iowa_data = None # Set to None if loading fails\n",
    "        dansbecker_home_data_for_ml_course_path = None # Also reset path\n",
    "\n",
    "else:\n",
    "    print(\"\\nSkipping Iowa Housing dataset loading due to Kaggle login failure.\")\n",
    "    iowa_data = None # Ensure variable is set to None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "54c18057",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-16T21:54:14.146394Z",
     "iopub.status.busy": "2025-05-16T21:54:14.146052Z",
     "iopub.status.idle": "2025-05-16T21:54:14.218841Z",
     "shell.execute_reply": "2025-05-16T21:54:14.217645Z"
    },
    "papermill": {
     "duration": 0.079014,
     "end_time": "2025-05-16T21:54:14.220501",
     "exception": false,
     "start_time": "2025-05-16T21:54:14.141487",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "----- Data Preprocessing and Splitting -----\n",
      "\n",
      "----------------------------------------------------------------------------\n",
      "\n",
      "----------------------------------------------------------------------------\n",
      "\n",
      "--- Preparing Iowa Housing data (Regression) ---\n",
      "Iowa Housing subset shape after selecting features and dropping missing SalePrice: (1460, 13)\n",
      "Features (X_iowa) shape: (1460, 12), Target (y_iowa) shape: (1460,)\n",
      "Iowa: 6 numerical, 6 categorical columns identified for preprocessing.\n",
      "NaN values in X_iowa before transformation: True\n",
      "Preprocessing steps defined for Iowa dataset.\n",
      "NaN values in X_iowa_transformed_df after transformation: False\n",
      "Performing train-test split for Iowa Housing...\n",
      "\n",
      "----------------------------------------------------------------------------\n",
      "Iowa Housing data split successfully.\n",
      "  Training data shape: (1168, 12), Training target shape: (1168,)\n",
      "  Testing data shape : (292, 12),   Testing target shape: (292,)\n",
      "\n",
      "----------------------------------------------------------------------------\n"
     ]
    }
   ],
   "source": [
    "# Data Preprocessing and Splitting (Separate for Each Dataset)\n",
    "# Now that we have loaded the raw dataframes for both datasets, we will perform the necessary preprocessing steps and split each dataset into training and testing sets independently.\n",
    "print(\"\\n----- Data Preprocessing and Splitting -----\")\n",
    "\n",
    "# --- Preprocess and Split Iowa Housing Data (Regression) ---\n",
    "print(\"\\n----------------------------------------------------------------------------\")\n",
    "print(\"\\n----------------------------------------------------------------------------\")\n",
    "print(\"\\n--- Preparing Iowa Housing data (Regression) ---\")\n",
    "\n",
    "X_iowa, y_iowa, preprocessor_iowa = None, None, None  # Initialize variables for features (X_iowa), target (y_iowa), and preprocessor (preprocessor_iowa) to None.\n",
    "\n",
    "# Define features to use (consistent with previous modules, including target)\n",
    "features_to_use_iowa = ['LotArea', 'OverallQual', 'YearBuilt', 'TotalBsmtSF', 'GrLivArea',\n",
    "                        'GarageArea', 'Neighborhood', 'BldgType', 'HouseStyle',\n",
    "                        'ExterQual', 'KitchenQual', 'FireplaceQu', 'SalePrice']\n",
    "\n",
    "# Create subset with selected features, handle missing target\n",
    "# Work on a copy to avoid modifying the original loaded dataframe\n",
    "iowa_data_processed = iowa_data[features_to_use_iowa].dropna(subset=['SalePrice']).copy()\n",
    "\n",
    "# Drop rows with missing 'SalePrice' values. Create a copy to avoid modifying the original data.\n",
    "\n",
    "print(f\"Iowa Housing subset shape after selecting features and dropping missing SalePrice: {iowa_data_processed.shape}\")\n",
    "\n",
    "# Separate target variable (y_iowa) and features (X_iowa)\n",
    "y_iowa = iowa_data_processed['SalePrice']\n",
    "# Assign the 'SalePrice' column to the target variable y_iowa.\n",
    "X_iowa = iowa_data_processed.drop('SalePrice', axis=1)\n",
    "# Assign the remaining columns (features) to X_iowa, dropping the 'SalePrice' column.\n",
    "\n",
    "print(f\"Features (X_iowa) shape: {X_iowa.shape}, Target (y_iowa) shape: {y_iowa.shape}\")\n",
    "\n",
    "# Identify numerical and categorical columns from the selected features\n",
    "numerical_cols_iowa   = X_iowa.select_dtypes(include=np.number).columns.tolist()\n",
    "# Identify numerical columns in X_iowa and convert them to a list.\n",
    "categorical_cols_iowa = X_iowa.select_dtypes(include='object').columns.tolist()\n",
    "# Identify categorical columns in X_iowa and convert them to a list.\n",
    "\n",
    "print(f\"Iowa: {len(numerical_cols_iowa)} numerical, {len(categorical_cols_iowa)} categorical columns identified for preprocessing.\")\n",
    "\n",
    "# Check and print if there are any NaN values before transformation\n",
    "print(f\"NaN values in X_iowa before transformation: {X_iowa.isnull().values.any()}\")\n",
    "\n",
    "# Define Preprocessing steps using ColumnTransformer\n",
    "# Numerical: Impute with median, then scale\n",
    "# Categorical: Impute with most frequent, then One-Hot Encode\n",
    "numerical_transformer_iowa = Pipeline([  # Define a pipeline for numerical features.\n",
    "                                      ('imputer', SimpleImputer(strategy='median')),\n",
    "                                         # Impute missing values with the median.\n",
    "                                      ('scaler' , StandardScaler())])\n",
    "                                         # Scale the numerical features using StandardScaler.\n",
    "\n",
    "categorical_transformer_iowa = Pipeline([  # Define a pipeline for categorical features.\n",
    "                                       ('imputer', SimpleImputer(strategy='most_frequent')),\n",
    "                                           # Impute missing values with the most frequent value.\n",
    "                                       ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=False))])\n",
    "                                          # One-hot encode the categorical features.\n",
    "\n",
    "# Create ColumnTransformer\n",
    "transformers_list_iowa = []  # Initialize an empty list to store transformers.\n",
    "transformers_list_iowa.append(('num', numerical_transformer_iowa,  numerical_cols_iowa))\n",
    "# Append the numerical transformer to the list.\n",
    "transformers_list_iowa.append(('cat', categorical_transformer_iowa,categorical_cols_iowa))\n",
    "# Append the categorical transformer to the list.\n",
    "\n",
    "# Create the preprocessor\n",
    "preprocessor_iowa = ColumnTransformer(transformers=transformers_list_iowa, remainder='drop')\n",
    "# Create the ColumnTransformer using the defined transformers and drop any remaining columns.\n",
    "\n",
    "print(\"Preprocessing steps defined for Iowa dataset.\")\n",
    "\n",
    "# Fit the preprocessor and transform the data\n",
    "X_iowa_transformed = preprocessor_iowa.fit_transform(X_iowa)\n",
    "# Fit the preprocessor to X_iowa and transform the data.\n",
    "\n",
    "# Convert the transformed data back to a DataFrame for NaN check\n",
    "X_iowa_transformed_df = pd.DataFrame(X_iowa_transformed)\n",
    "# Convert the transformed data back to a DataFrame.\n",
    "\n",
    "# Check and print if there are any NaN values after transformation\n",
    "print(f\"NaN values in X_iowa_transformed_df after transformation: {X_iowa_transformed_df.isnull().values.any()}\")\n",
    "\n",
    "# Split Iowa data into training and testing sets\n",
    "print(\"Performing train-test split for Iowa Housing...\")\n",
    "\n",
    "X_train_iowa, X_test_iowa, y_train_iowa, y_test_iowa = train_test_split(  # Split the data into training and testing sets using train_test_split.\n",
    "                        X_iowa, y_iowa,  # Input features (X_iowa) and target variable (y_iowa).\n",
    "                        test_size=0.2,      # Use 20% of data for testing.\n",
    "                        random_state=42     # Ensure reproducibility of the split.\n",
    "                        )\n",
    "\n",
    "print(\"\\n----------------------------------------------------------------------------\")\n",
    "print(\"Iowa Housing data split successfully.\")\n",
    "print(f\"  Training data shape: {X_train_iowa.shape}, Training target shape: {y_train_iowa.shape}\")\n",
    "print(f\"  Testing data shape : {X_test_iowa.shape},   Testing target shape: {y_test_iowa.shape}\")\n",
    "print(\"\\n----------------------------------------------------------------------------\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "cff21ddb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-16T21:54:14.228440Z",
     "iopub.status.busy": "2025-05-16T21:54:14.228075Z",
     "iopub.status.idle": "2025-05-16T21:55:04.528807Z",
     "shell.execute_reply": "2025-05-16T21:55:04.527576Z"
    },
    "papermill": {
     "duration": 50.310921,
     "end_time": "2025-05-16T21:55:04.534649",
     "exception": false,
     "start_time": "2025-05-16T21:54:14.223728",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "==================================================\n",
      "--- Tuning GradientBoostingRegressor and XGBRegressor on Iowa Housing ---\n",
      "==================================================\n",
      "Using 'neg_mean_squared_error' for RandomizedSearchCV (maximizes) and 'rmse' for final evaluation (minimizes).\n",
      "\n",
      "Starting RandomizedSearchCV for GBM...\n",
      "Fitting 5 folds for each of 20 candidates, totalling 100 fits\n",
      "RandomizedSearchCV for GBM finished.\n",
      "Random Search execution time: 50.29 seconds\n",
      "\n",
      "--- RandomizedSearchCV Results (GBM) ---\n",
      "Best parameters found:  {'model__learning_rate': 0.0330893825622149, 'model__max_depth': 6, 'model__n_estimators': 466, 'model__subsample': 0.8049790556476375}\n",
      "Best cross-validation score (neg_MSE):  -872259338.6648967\n",
      "Equivalent best CV RMSE:  29534.03695170873\n"
     ]
    }
   ],
   "source": [
    "# --- Tuning GradientBoostingRegressor and XGBRegressor on Iowa Housing (Regression) ---\n",
    "print(\"\\n\" + \"=\"*50)\n",
    "print(\"--- Tuning GradientBoostingRegressor and XGBRegressor on Iowa Housing ---\")\n",
    "print(\"=\"*50)\n",
    "\n",
    "# Import necessary libraries (if not already imported)\n",
    "from sklearn.metrics import mean_absolute_error\n",
    "from xgboost import XGBRegressor\n",
    "from sklearn.model_selection import RandomizedSearchCV\n",
    "from scipy.stats import randint, uniform\n",
    "\n",
    "# Define tuning and evaluation metrics for Regression\n",
    "scoring_metric_gbm = 'neg_mean_squared_error'\n",
    "# Scoring metric for RandomizedSearchCV (Maximize negative MSE = Minimize MSE)\n",
    "eval_metric_gbm = rmse\n",
    "# Evaluation metric for final evaluation (Calculate RMSE, lower is better)\n",
    "\n",
    "print(f\"Using '{scoring_metric_gbm}' for RandomizedSearchCV (maximizes) and '{eval_metric_gbm.__name__}' for final evaluation (minimizes).\")\n",
    "\n",
    "\n",
    "# --- Gradient Boosting Regression with RandomizedSearchCV ---\n",
    "\n",
    "# Step 1: Define the Pipeline for GBM (same as before)\n",
    "pipeline_gbm = Pipeline([ # Create a pipeline for GBM\n",
    "                       ('preprocessor', preprocessor_iowa),\n",
    "                          # Use the Iowa preprocessor from earlier cell\n",
    "                       ('model', GradientBoostingRegressor(random_state=42))\n",
    "                          # Use the GBM model with a random state for reproducibility\n",
    "])\n",
    "\n",
    "# Step 2: Define the Parameter Distributions for RandomizedSearchCV (Objective 5)\n",
    "param_distributions_gbm = { # Define the parameter distributions for GBM\n",
    "    'model__n_estimators' : randint(100, 500),\n",
    "                            # Number of estimators (trees), drawn from a uniform distribution between 100 and 500\n",
    "    'model__learning_rate': uniform(0.01, 0.1),\n",
    "                            # Learning rate, drawn from a uniform distribution between 0.01 and 0.1\n",
    "    'model__max_depth'    : randint(3, 8),\n",
    "                            # Maximum depth of trees, drawn from a uniform distribution between 3 and 8\n",
    "    'model__subsample'    : uniform(0.6, 0.3),\n",
    "                            # Subsample ratio, drawn from a uniform distribution between 0.6 and 0.9 (0.6 + 0.3)\n",
    "}\n",
    "\n",
    "\n",
    "# Step 3: Set up RandomizedSearchCV (Objective 3, 4)\n",
    "random_search_gbm = RandomizedSearchCV( # Create a RandomizedSearchCV object\n",
    "    estimator=pipeline_gbm,                      # Use the defined GBM pipeline\n",
    "    param_distributions=param_distributions_gbm, # Use the defined parameter distributions\n",
    "    scoring=scoring_metric_gbm,                  # Use negative MSE as the scoring metric\n",
    "    cv=5,                                        # Perform 5-fold cross-validation\n",
    "    n_iter=20,                                   # Try 20 random parameter combinations\n",
    "    n_jobs=-1,                                   # Use all available CPU cores\n",
    "    verbose=1,                                   # Print progress messages\n",
    "    random_state=42                              # Set random state for reproducibility\n",
    ")\n",
    "\n",
    "# Step 4: Execute the Search\n",
    "print(f\"\\nStarting RandomizedSearchCV for GBM...\")\n",
    "start_time_gbm_random = time.time() # Record the start time\n",
    "random_search_gbm.fit(X_train_iowa, y_train_iowa) # Fit the RandomizedSearchCV object to the training data\n",
    "end_time_gbm_random = time.time()  # Record the end time\n",
    "\n",
    "print(\"RandomizedSearchCV for GBM finished.\")\n",
    "print(f\"Random Search execution time: {end_time_gbm_random - start_time_gbm_random:.2f} seconds\")\n",
    "\n",
    "# Step 5: Get Results\n",
    "print(\"\\n--- RandomizedSearchCV Results (GBM) ---\")\n",
    "print(\"Best parameters found: \", random_search_gbm.best_params_)\n",
    "print(\"Best cross-validation score (neg_MSE): \", random_search_gbm.best_score_)\n",
    "print(\"Equivalent best CV RMSE: \", np.sqrt(-random_search_gbm.best_score_))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b6c7e0d8",
   "metadata": {
    "papermill": {
     "duration": 0.002941,
     "end_time": "2025-05-16T21:55:04.540908",
     "exception": false,
     "start_time": "2025-05-16T21:55:04.537967",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "**2. Implement Grid Search:**\n",
    "\n",
    "- Using the refined parameter grid, apply Grid Search (`GridSearchCV`) to the Gradient Boosting Regressor, using the same pipeline and scoring metric as before."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "c074691c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-05-16T21:55:04.549400Z",
     "iopub.status.busy": "2025-05-16T21:55:04.548504Z",
     "iopub.status.idle": "2025-05-16T21:55:48.724364Z",
     "shell.execute_reply": "2025-05-16T21:55:48.723014Z"
    },
    "papermill": {
     "duration": 44.184472,
     "end_time": "2025-05-16T21:55:48.728594",
     "exception": false,
     "start_time": "2025-05-16T21:55:04.544122",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Starting GridSearchCV for GBM...\n",
      "GridSearchCV for GBM finished.\n",
      "GridSearchCV execution time: 44.15 seconds\n",
      "GridSearchCV Completed!\n",
      "\n",
      "Best Parameters from GridSearchCV hyperparameter combination found:\n",
      "{'model__learning_rate': 0.01, 'model__max_depth': 7, 'model__n_estimators': 400, 'model__subsample': 0.08}\n",
      "\n",
      "Best Score from GridSearchCV (Negative MAE) achieved with cross-validation:\n",
      "-18065.951045267433\n",
      "\n",
      "---------------------------------------------------------------------------------\n"
     ]
    }
   ],
   "source": [
    "# --- Define Hyperparameter Grid for GridSearchCV ---\n",
    "# Define the hyperparameter grid to search\n",
    "param_distributions_gbm = { # Define the parameter distributions for GBM\n",
    "    'model__n_estimators' : range(100, 500, 100),\n",
    "                            # Number of estimators (trees), drawn from a uniform distribution between 100 and 500\n",
    "    'model__learning_rate': [0.01, 0.1, 0.5],\n",
    "                            # Learning rate, drawn from a uniform distribution between 0.01 and 0.1\n",
    "    'model__max_depth'    : range(3, 8, 2),\n",
    "                            # Maximum depth of trees, drawn from a uniform distribution between 3 and 8\n",
    "    'model__subsample'    : [0.02, 0.05, 0.08],\n",
    "                            # Subsample ratio, drawn from a uniform distribution between 0.6 and 0.9 (0.6 + 0.3)\n",
    "}\n",
    "\n",
    "# --- Perform GridSearchCV with Pipeline ---\n",
    "# Create a GridSearchCV object to perform hyperparameter tuning\n",
    "grid_search = GridSearchCV(pipeline_gbm,\n",
    "                           # The main pipeline, including the preprocessor and the model\n",
    "                           param_distributions_gbm,\n",
    "                           # The hyperparameter grid to search\n",
    "                           cv=5,\n",
    "                           # Use 5-fold cross-validation\n",
    "                           scoring='neg_mean_absolute_error',\n",
    "                           # Use negative MAE as the scoring metric\n",
    "                           n_jobs=-1)\n",
    "                           # Use all available CPU cores for parallel processing\n",
    "\n",
    "# Fit the GridSearchCV object to the training data to find the best hyperparameters\n",
    "print(f\"\\nStarting GridSearchCV for GBM...\")\n",
    "start_time_gbm_grid = time.time() # Record the start time\n",
    "grid_search.fit(X_train_iowa, y_train_iowa)\n",
    "end_time_gbm_grid = time.time()  # Record the end time\n",
    "\n",
    "print(\"GridSearchCV for GBM finished.\")\n",
    "print(f\"GridSearchCV execution time: {end_time_gbm_grid - start_time_gbm_grid:.2f} seconds\")\n",
    "\n",
    "# --- Best Parameters and Best Score from GridSearchCV ---\n",
    "\n",
    "# Get the best pipeline (with the tuned hyperparameters)\n",
    "best_pipeline = grid_search.best_estimator_\n",
    "\n",
    "# Make predictions on the validation set using the best pipeline\n",
    "predictions_best = best_pipeline.predict(X_test_iowa)\n",
    "\n",
    "# Calculate the MAE on the validation set using the predictions from the best pipeline\n",
    "mae_best = mean_absolute_error(y_test_iowa, predictions_best)\n",
    "\n",
    "print(\"GridSearchCV Completed!\")\n",
    "\n",
    "# --- Best Parameters and Best Score from GridSearchCV ---\n",
    "print(\"\\nBest Parameters from GridSearchCV hyperparameter combination found:\")\n",
    "print(grid_search.best_params_) # Best hyperparameter combination found\n",
    "print(\"\\nBest Score from GridSearchCV (Negative MAE) achieved with cross-validation:\")\n",
    "print(grid_search.best_score_) # Best score (negative MAE) achieved with cross-validation\n",
    "print(\"\\n---------------------------------------------------------------------------------\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ab52256c",
   "metadata": {
    "papermill": {
     "duration": 0.00315,
     "end_time": "2025-05-16T21:55:48.735603",
     "exception": false,
     "start_time": "2025-05-16T21:55:48.732453",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "**3. Compare Results:**\n",
    "\n",
    "- After running both Randomized Search and Grid Search, compare the following aspects:\n",
    "\n",
    "- **Best parameters found:** Do both methods converge to similar parameter values? Are there any notable differences?\n",
    "    - ## Best parameters from RandomizedSearchCV: {'model__learning_rate': 0.0330893825622149, 'model__max_depth': 6, 'model__n_estimators': 466, 'model__subsample': 0.8049790556476375}\n",
    "    - ## Best Parameters from GridSearchCV: {'model__learning_rate': 0.01, 'model__max_depth': 7, 'model__n_estimators': 400, 'model__subsample': 0.08}\n",
    "## - When we look at the results, most of the parameters look so near to each other for both methods instead of subsample. subsampleis notable different. Additionally, there are a certain difference between learning_rate values.\n",
    "\n",
    "- **Cross-validation scores:** How do the best scores achieved by each method compare? Is there a significant difference in performance?\n",
    "    ## - 872259338.6648967 vs. 18065.951045267433 It is obvious that mean squared value of GridSeach is highly better than Randomized.\n",
    "- **Execution time:** Compare the total time taken by each search method. How much faster (or slower) is Randomized Search compared to Grid Search for this specific task?\n",
    "    ## - Random Search execution time: 51.82 seconds and GridSearchCV execution time: 45.50 seconds. However, I must confest that I gave narrower range of parameters to GridSearch so GridSearch took little bit shorter than Randomized. As we all know, if conditions are the same, Randomized finishes very earlier than GridSearch.\n",
    "- **Test set performance:** Evaluate the best models found by each method on the test set. Do the differences observed in cross-validation scores translate to the test set?\n",
    "    ## - Mean squared error value of Randomized is so high which one is not acceptable and can't be taken into consideration that approximatelly 5000 times bigger than the loss of GridSearch resulted."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e72baa70",
   "metadata": {
    "papermill": {
     "duration": 0.003059,
     "end_time": "2025-05-16T21:55:48.742070",
     "exception": false,
     "start_time": "2025-05-16T21:55:48.739011",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "**4. Analysis and Conclusions:**\n",
    "\n",
    "- Based on your observations, discuss the advantages and disadvantages of each search method in this particular scenario.\n",
    "- Which method would you recommend for this dataset and model, and why?\n",
    "- Consider factors like computational cost, performance, and the desired level of exploration vs. exploitation of the parameter space.\n",
    "## - I would be exactly saying that I would recommend GridSearch because it behaves perfectly in this dataset in terms of time costs, hightly valuable mean squared error value and choosing so critical paramaters amongst different options. So, GridSearch has an obvious dominant on Randomized in this dataset."
   ]
  }
 ],
 "metadata": {
  "colab": {
   "authorship_tag": "ABX9TyNZGVKB6J8ym/XVndbqXd90",
   "provenance": []
  },
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 108980,
     "sourceId": 260251,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 31012,
   "isGpuEnabled": false,
   "isInternetEnabled": false,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 108.246903,
   "end_time": "2025-05-16T21:55:51.366624",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-05-16T21:54:03.119721",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "05a7d864f26e4a1882498c68398bc3e8": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "0a8c13060219417fb191b7c9db1b28f9": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ButtonStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ButtonStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "button_color": null,
       "font_family": null,
       "font_size": null,
       "font_style": null,
       "font_variant": null,
       "font_weight": null,
       "text_color": null,
       "text_decoration": null
      }
     },
     "12f44233f43a44acbf9dc25623c4bba4": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "PasswordModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "PasswordModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "PasswordView",
       "continuous_update": true,
       "description": "Token:",
       "description_allow_html": false,
       "disabled": false,
       "layout": "IPY_MODEL_41eefb9a58444ecaa97db17f2de0e28b",
       "placeholder": "​",
       "style": "IPY_MODEL_e216799d509940468ac973736ba838ef",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     },
     "37b43156df8346eb9eb435d8ef5c6d6a": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "3e278e6865784cc48237591e17062380": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "41eefb9a58444ecaa97db17f2de0e28b": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "5c88e0e1ae494300a52a5610c4293c09": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "6aaf18eaf654474dbb240c69f41f931f": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": "center",
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": "flex",
       "flex": null,
       "flex_flow": "column",
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "50%"
      }
     },
     "7267fb8622c34cc186f7ae96b7f615a0": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "VBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "VBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "VBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_b70281f20c2d4a6ca9b7f984a8b87818",
        "IPY_MODEL_eb93d85066884165a044d0ba176532c6",
        "IPY_MODEL_12f44233f43a44acbf9dc25623c4bba4",
        "IPY_MODEL_c82203188b0d4b2ab3b312ee1cb24dd6",
        "IPY_MODEL_a7bcd11ef0c34ac28e2027c4503d78fb"
       ],
       "layout": "IPY_MODEL_6aaf18eaf654474dbb240c69f41f931f",
       "tabbable": null,
       "tooltip": null
      }
     },
     "72cbbb2265dd4752ab842697c41583a4": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "9a8dead0325d4721a655f172cb16292b": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "a7bcd11ef0c34ac28e2027c4503d78fb": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_5c88e0e1ae494300a52a5610c4293c09",
       "placeholder": "​",
       "style": "IPY_MODEL_3e278e6865784cc48237591e17062380",
       "tabbable": null,
       "tooltip": null,
       "value": "\n<b>Thank You</b></center>"
      }
     },
     "b54f1e14b1d34a768f263ae2127f02d4": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "TextStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "TextStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "b70281f20c2d4a6ca9b7f984a8b87818": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_72cbbb2265dd4752ab842697c41583a4",
       "placeholder": "​",
       "style": "IPY_MODEL_9a8dead0325d4721a655f172cb16292b",
       "tabbable": null,
       "tooltip": null,
       "value": "<center> <img\nsrc=https://www.kaggle.com/static/images/site-logo.png\nalt='Kaggle'> <br> Create an API token from <a\nhref=\"https://www.kaggle.com/settings/account\" target=\"_blank\">your Kaggle\nsettings page</a> and paste it below along with your Kaggle username. <br> </center>"
      }
     },
     "c82203188b0d4b2ab3b312ee1cb24dd6": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ButtonModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ButtonModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ButtonView",
       "button_style": "",
       "description": "Login",
       "disabled": false,
       "icon": "",
       "layout": "IPY_MODEL_05a7d864f26e4a1882498c68398bc3e8",
       "style": "IPY_MODEL_0a8c13060219417fb191b7c9db1b28f9",
       "tabbable": null,
       "tooltip": null
      }
     },
     "e216799d509940468ac973736ba838ef": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "TextStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "TextStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "eb93d85066884165a044d0ba176532c6": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "TextModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "TextModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "TextView",
       "continuous_update": true,
       "description": "Username:",
       "description_allow_html": false,
       "disabled": false,
       "layout": "IPY_MODEL_37b43156df8346eb9eb435d8ef5c6d6a",
       "placeholder": "​",
       "style": "IPY_MODEL_b54f1e14b1d34a768f263ae2127f02d4",
       "tabbable": null,
       "tooltip": null,
       "value": ""
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
